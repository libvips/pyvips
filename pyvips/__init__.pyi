"""Type stubs for pyvips.

This file is automatically generated by pyvips/generate_type_stubs.py.

RATIONALE FOR GENERATION:
- pyvips is a binding around libvips C library
- libvips has 300+ operations that change frequently
- Manual stub maintenance would be unmaintainable
- Generation uses same introspection as docs/ enums
- Ensures stubs stay synchronized with available operations

To regenerate after libvips updates:
    python pyvips/generate_type_stubs.py
"""

from __future__ import annotations
from typing import Dict, List, Optional, Tuple, TypeVar, Union, overload

# Exception classes
class Error(Exception): ...

# GObject base classes
class GObject: ...
class GValue: ...

# Connection classes
class Source: ...
class Target: ...

# Enum classes
class Access: ...
class Align: ...
class Angle: ...
class Angle45: ...
class BandFormat: ...
class BlendMode: ...
class Coding: ...
class Combine: ...
class CombineMode: ...
class CompassDirection: ...
class Direction: ...
class Extend: ...
class FailOn: ...
class Intent: ...
class Interesting: ...
class Interpretation: ...
class Kernel: ...
class OperationBoolean: ...
class OperationComplex: ...
class OperationComplex2: ...
class OperationComplexget: ...
class OperationMath: ...
class OperationMath2: ...
class OperationMorphology: ...
class OperationRelational: ...
class OperationRound: ...
class PCS: ...
class Precision: ...
class SdfShape: ...
class Shrink: ...
class TextWrap: ...


class Image:
    """Wrap a VipsImage object."""

    # Properties
    @property
    def width(self) -> int: ...
    @property
    def height(self) -> int: ...
    @property
    def bands(self) -> int: ...
    @property
    def format(self) -> Union[str, BandFormat]: ...
    @property
    def interpretation(self) -> Union[str, Interpretation]: ...
    @property
    def xres(self) -> float: ...
    @property
    def yres(self) -> float: ...
    @property
    def xoffset(self) -> int: ...
    @property
    def yoffset(self) -> int: ...

    # Metadata methods
    # GValue can return: bool, int, float, str, Image, list[int], list[float], list[Image]
    def get_typeof(self, name: str) -> int: ...
    def get(self, name: str) -> Union[bool, int, float, str, Image, list[int], list[float], list[Image]]: ...
    def get_fields(self) -> List[str]: ...
    def set_type(self, gtype: int, name: str, value: Union[bool, int, float, str, Image, list[int], list[float], list[Image]]) -> None: ...
    def set(self, name: str, value: Union[bool, int, float, str, Image, list[int], list[float], list[Image]]) -> None: ...
    def remove(self, name: str) -> bool: ...

    # Constructors
    @staticmethod
    def new_from_file(vips_filename: str, **kwargs: object) -> Image: ...
    @staticmethod
    def new_from_buffer(data: Union[bytes, bytearray, memoryview], options: str, **kwargs: object) -> Image: ...
    @staticmethod
    def new_from_list(array: List[List[float]], scale: float =1.0, offset: float = 0.0) -> Image: ...
    @classmethod
    def new_from_array(cls, obj: Union[List, bytes, bytearray, memoryview], scale: float = 1.0, offset: float = 0.0, interpretation: Optional[Union[str, Interpretation]] = None) -> Image: ...
    @staticmethod
    def new_from_memory(data: Union[bytes, bytearray, memoryview], width: int, height: int, bands: int, format: Union[str, BandFormat]) -> Image: ...
    @staticmethod
    def new_from_source(source: Source, options: str, **kwargs: object) -> Image: ...
    @staticmethod
    def new_temp_file(format: str) -> Image: ...
    def new_from_image(self, value: Union[float, List[float]]) -> Image: ...
    def copy_memory(self) -> Image: ...

    # Writers
    def write_to_file(self, vips_filename: str, **kwargs: object) -> None: ...
    def write_to_buffer(self, format_string: str, **kwargs: object) -> bytes: ...
    def write_to_target(self, target: Target, format_string: str, **kwargs: object) -> None: ...
    def write_to_memory(self) -> bytes: ...
    def write(self, other: Image) -> None: ...

    # Utility methods
    def invalidate(self) -> None: ...
    def set_progress(self, progress: bool) -> None: ...
    def set_kill(self, kill: bool) -> None: ...
    def copy(self, **kwargs: object) -> Image: ...
    def tolist(self) -> List[List[float]]: ...
    # numpy is optional dependency - use TYPE_CHECKING guard
    def __array__(self, dtype: Optional[str] = None, copy: Optional[bool] = None) -> object: ...
    def numpy(self, dtype: Optional[str] = None) -> object: ...

    # Dynamically generated operations
    def CMC2LCh(self) -> Image: ...
    def CMYK2XYZ(self) -> Image: ...
    def HSV2sRGB(self) -> Image: ...
    def LCh2CMC(self) -> Image: ...
    def LCh2Lab(self) -> Image: ...
    def Lab2LCh(self) -> Image: ...
    def Lab2LabQ(self) -> Image: ...
    def Lab2LabS(self) -> Image: ...
    def Lab2XYZ(self, temp: list[float] = ...) -> Image: ...
    def LabQ2Lab(self) -> Image: ...
    def LabQ2LabS(self) -> Image: ...
    def LabQ2sRGB(self) -> Image: ...
    def LabS2Lab(self) -> Image: ...
    def LabS2LabQ(self) -> Image: ...
    def XYZ2CMYK(self) -> Image: ...
    def XYZ2Lab(self, temp: list[float] = ...) -> Image: ...
    def XYZ2Yxy(self) -> Image: ...
    def XYZ2scRGB(self) -> Image: ...
    def Yxy2XYZ(self) -> Image: ...
    def abs(self) -> Image: ...
    def add(self, right: Image) -> Image: ...
    def addalpha(self) -> Image: ...
    def affine(self, matrix: list[float], interpolate: GObject = ..., oarea: list[int] = ..., odx: float = ..., ody: float = ..., idx: float = ..., idy: float = ..., background: list[float] = ..., premultiplied: bool = ..., extend: Union[str, Extend] = ...) -> Image: ...
    @staticmethod
    def analyzeload(filename: str, memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def arrayjoin(in_: list[Image], across: int = ..., shim: int = ..., background: list[float] = ..., halign: Union[str, Align] = ..., valign: Union[str, Align] = ..., hspacing: int = ..., vspacing: int = ...) -> Image: ...
    def autorot(self, angle: bool = ..., flip: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def avg(self) -> float: ...
    def bandbool(self, boolean: Union[str, OperationBoolean]) -> Image: ...
    def bandfold(self, factor: int = ...) -> Image: ...
    def bandjoin_const(self, c: list[float]) -> Image: ...
    def bandmean(self) -> Image: ...
    def bandunfold(self, factor: int = ...) -> Image: ...
    @staticmethod
    def black(width: int, height: int, bands: int = ...) -> Image: ...
    def boolean(self, right: Image, boolean: Union[str, OperationBoolean]) -> Image: ...
    def boolean_const(self, boolean: Union[str, OperationBoolean], c: list[float]) -> Image: ...
    def buildlut(self) -> Image: ...
    def byteswap(self) -> Image: ...
    def cache(self, max_tiles: int = ..., tile_height: int = ..., tile_width: int = ...) -> Image: ...
    def canny(self, sigma: float = ..., precision: Union[str, Precision] = ...) -> Image: ...
    def case(self, cases: list[Image]) -> Image: ...
    def cast(self, format: Union[str, BandFormat], shift: bool = ...) -> Image: ...
    def clamp(self, min_: float = ..., max_: float = ...) -> Image: ...
    def colourspace(self, space: Union[str, Interpretation], source_space: Union[str, Interpretation] = ...) -> Image: ...
    def compass(self, mask: Image, times: int = ..., angle: Union[str, Angle45] = ..., combine: Union[str, Combine] = ..., precision: Union[str, Precision] = ..., layers: int = ..., cluster: int = ...) -> Image: ...
    def complex(self, cmplx: Union[str, OperationComplex]) -> Image: ...
    def complex2(self, right: Image, cmplx: Union[str, OperationComplex2]) -> Image: ...
    def complexform(self, right: Image) -> Image: ...
    def complexget(self, get: Union[str, OperationComplexget]) -> Image: ...
    @staticmethod
    def composite(in_: list[Image], mode: list[int], x: list[int] = ..., y: list[int] = ..., compositing_space: Union[str, Interpretation] = ..., premultiplied: bool = ...) -> Image: ...
    def composite2(self, overlay: Image, mode: Union[str, BlendMode], x: int = ..., y: int = ..., compositing_space: Union[str, Interpretation] = ..., premultiplied: bool = ...) -> Image: ...
    def conv(self, mask: Image, precision: Union[str, Precision] = ..., layers: int = ..., cluster: int = ...) -> Image: ...
    def conva(self, mask: Image, layers: int = ..., cluster: int = ...) -> Image: ...
    def convasep(self, mask: Image, layers: int = ...) -> Image: ...
    def convf(self, mask: Image) -> Image: ...
    def convi(self, mask: Image) -> Image: ...
    def convsep(self, mask: Image, precision: Union[str, Precision] = ..., layers: int = ..., cluster: int = ...) -> Image: ...
    def countlines(self, direction: Union[str, Direction]) -> float: ...
    def crop(self, left: int, top: int, width: int, height: int) -> Image: ...
    @staticmethod
    def csvload(filename: str, skip: int = ..., lines: int = ..., whitespace: str = ..., separator: str = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def dE00(self, right: Image) -> Image: ...
    def dE76(self, right: Image) -> Image: ...
    def dECMC(self, right: Image) -> Image: ...
    def deviate(self) -> float: ...
    def divide(self, right: Image) -> Image: ...
    def draw_circle(self, ink: list[float], cx: int, cy: int, radius: int, fill: bool = ...) -> Image: ...
    def draw_flood(self, ink: list[float], x: int, y: int, test: Image = ..., equal: bool = ..., left: bool = ..., top: bool = ..., width: bool = ..., height: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def draw_image(self, sub: Image, x: int, y: int, mode: Union[str, CombineMode] = ...) -> Image: ...
    def draw_line(self, ink: list[float], x1: int, y1: int, x2: int, y2: int) -> Image: ...
    def draw_mask(self, ink: list[float], mask: Image, x: int, y: int) -> Image: ...
    def draw_rect(self, ink: list[float], left: int, top: int, width: int, height: int, fill: bool = ...) -> Image: ...
    def draw_smudge(self, left: int, top: int, width: int, height: int) -> Image: ...
    def embed(self, x: int, y: int, width: int, height: int, extend: Union[str, Extend] = ..., background: list[float] = ...) -> Image: ...
    def extract_area(self, left: int, top: int, width: int, height: int) -> Image: ...
    def extract_band(self, band: int, n: int = ...) -> Image: ...
    @staticmethod
    def eye(width: int, height: int, uchar: bool = ..., factor: float = ...) -> Image: ...
    def falsecolour(self) -> Image: ...
    def fastcor(self, ref: Image) -> Image: ...
    def fill_nearest(self, distance: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def find_trim(self, threshold: float = ..., background: list[float] = ..., line_art: bool = ...) -> tuple[int, int, int, int]: ...
    @staticmethod
    def fitsload(filename: str, memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def flatten(self, background: list[float] = ..., max_alpha: float = ...) -> Image: ...
    def flip(self, direction: Union[str, Direction]) -> Image: ...
    def float2rad(self) -> Image: ...
    @staticmethod
    def fractsurf(width: int, height: int, fractal_dimension: float) -> Image: ...
    def freqmult(self, mask: Image) -> Image: ...
    def fwfft(self) -> Image: ...
    def gamma(self, exponent: float = ...) -> Image: ...
    def gaussblur(self, sigma: float, min_ampl: float = ..., precision: Union[str, Precision] = ...) -> Image: ...
    @staticmethod
    def gaussmat(sigma: float, min_ampl: float, separable: bool = ..., precision: Union[str, Precision] = ...) -> Image: ...
    def getpoint(self, x: int, y: int, unpack_complex: bool = ...) -> list[float]: ...
    @staticmethod
    def gifload(filename: str, n: int = ..., page: int = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def gifload_buffer(buffer: str, n: int = ..., page: int = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def globalbalance(self, gamma: float = ..., int_output: bool = ...) -> Image: ...
    def gravity(self, direction: Union[str, CompassDirection], width: int, height: int, extend: Union[str, Extend] = ..., background: list[float] = ...) -> Image: ...
    @staticmethod
    def grey(width: int, height: int, uchar: bool = ...) -> Image: ...
    def grid(self, tile_height: int, across: int, down: int) -> Image: ...
    @staticmethod
    def heifload(filename: str, page: int = ..., n: int = ..., thumbnail: bool = ..., unlimited: bool = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def heifload_buffer(buffer: str, page: int = ..., n: int = ..., thumbnail: bool = ..., unlimited: bool = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def hist_cum(self) -> Image: ...
    def hist_entropy(self) -> float: ...
    def hist_equal(self, band: int = ...) -> Image: ...
    def hist_find(self, band: int = ...) -> Image: ...
    def hist_find_indexed(self, index: Image, combine: Union[str, Combine] = ...) -> Image: ...
    def hist_find_ndim(self, bins: int = ...) -> Image: ...
    def hist_ismonotonic(self) -> bool: ...
    def hist_local(self, width: int, height: int, max_slope: int = ...) -> Image: ...
    def hist_match(self, ref: Image) -> Image: ...
    def hist_norm(self) -> Image: ...
    def hist_plot(self) -> Image: ...
    def hough_circle(self, scale: int = ..., min_radius: int = ..., max_radius: int = ...) -> Image: ...
    def hough_line(self, width: int = ..., height: int = ...) -> Image: ...
    def icc_export(self, pcs: Union[str, PCS] = ..., intent: Union[str, Intent] = ..., black_point_compensation: bool = ..., output_profile: str = ..., depth: int = ...) -> Image: ...
    def icc_import(self, pcs: Union[str, PCS] = ..., intent: Union[str, Intent] = ..., black_point_compensation: bool = ..., embedded: bool = ..., input_profile: str = ...) -> Image: ...
    def icc_transform(self, output_profile: str, pcs: Union[str, PCS] = ..., intent: Union[str, Intent] = ..., black_point_compensation: bool = ..., embedded: bool = ..., input_profile: str = ..., depth: int = ...) -> Image: ...
    @staticmethod
    def identity(bands: int = ..., ushort: bool = ..., size: int = ...) -> Image: ...
    def insert(self, sub: Image, x: int, y: int, expand: bool = ..., background: list[float] = ...) -> Image: ...
    def invert(self) -> Image: ...
    def invertlut(self, size: int = ...) -> Image: ...
    def invfft(self, real: bool = ...) -> Image: ...
    def join(self, in2: Image, direction: Union[str, Direction], expand: bool = ..., shim: int = ..., background: list[float] = ..., align: Union[str, Align] = ...) -> Image: ...
    @staticmethod
    def jp2kload(filename: str, page: int = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def jp2kload_buffer(buffer: str, page: int = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def jpegload(filename: str, shrink: int = ..., autorotate: bool = ..., unlimited: bool = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def jpegload_buffer(buffer: str, shrink: int = ..., autorotate: bool = ..., unlimited: bool = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def jxlload(filename: str, page: int = ..., n: int = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def jxlload_buffer(buffer: str, page: int = ..., n: int = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def labelregions(self, segments: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def linear(self, a: list[float], b: list[float], uchar: bool = ...) -> Image: ...
    def linecache(self, tile_height: int = ..., access: Union[str, Access] = ..., threaded: bool = ..., persistent: bool = ...) -> Image: ...
    @staticmethod
    def logmat(sigma: float, min_ampl: float, separable: bool = ..., precision: Union[str, Precision] = ...) -> Image: ...
    def mapim(self, index: Image, interpolate: GObject = ..., background: list[float] = ..., premultiplied: bool = ..., extend: Union[str, Extend] = ...) -> Image: ...
    def maplut(self, lut: Image, band: int = ...) -> Image: ...
    @staticmethod
    def mask_butterworth(width: int, height: int, order: float, frequency_cutoff: float, amplitude_cutoff: float, uchar: bool = ..., nodc: bool = ..., reject: bool = ..., optical: bool = ...) -> Image: ...
    @staticmethod
    def mask_butterworth_band(width: int, height: int, order: float, frequency_cutoff_x: float, frequency_cutoff_y: float, radius: float, amplitude_cutoff: float, uchar: bool = ..., nodc: bool = ..., reject: bool = ..., optical: bool = ...) -> Image: ...
    @staticmethod
    def mask_butterworth_ring(width: int, height: int, order: float, frequency_cutoff: float, amplitude_cutoff: float, ringwidth: float, uchar: bool = ..., nodc: bool = ..., reject: bool = ..., optical: bool = ...) -> Image: ...
    @staticmethod
    def mask_fractal(width: int, height: int, fractal_dimension: float, uchar: bool = ..., nodc: bool = ..., reject: bool = ..., optical: bool = ...) -> Image: ...
    @staticmethod
    def mask_gaussian(width: int, height: int, frequency_cutoff: float, amplitude_cutoff: float, uchar: bool = ..., nodc: bool = ..., reject: bool = ..., optical: bool = ...) -> Image: ...
    @staticmethod
    def mask_gaussian_band(width: int, height: int, frequency_cutoff_x: float, frequency_cutoff_y: float, radius: float, amplitude_cutoff: float, uchar: bool = ..., nodc: bool = ..., reject: bool = ..., optical: bool = ...) -> Image: ...
    @staticmethod
    def mask_gaussian_ring(width: int, height: int, frequency_cutoff: float, amplitude_cutoff: float, ringwidth: float, uchar: bool = ..., nodc: bool = ..., reject: bool = ..., optical: bool = ...) -> Image: ...
    @staticmethod
    def mask_ideal(width: int, height: int, frequency_cutoff: float, uchar: bool = ..., nodc: bool = ..., reject: bool = ..., optical: bool = ...) -> Image: ...
    @staticmethod
    def mask_ideal_band(width: int, height: int, frequency_cutoff_x: float, frequency_cutoff_y: float, radius: float, uchar: bool = ..., nodc: bool = ..., reject: bool = ..., optical: bool = ...) -> Image: ...
    @staticmethod
    def mask_ideal_ring(width: int, height: int, frequency_cutoff: float, ringwidth: float, uchar: bool = ..., nodc: bool = ..., reject: bool = ..., optical: bool = ...) -> Image: ...
    def match(self, sec: Image, xr1: int, yr1: int, xs1: int, ys1: int, xr2: int, yr2: int, xs2: int, ys2: int, hwindow: int = ..., harea: int = ..., search: bool = ..., interpolate: GObject = ...) -> Image: ...
    def math(self, math: Union[str, OperationMath]) -> Image: ...
    def math2(self, right: Image, math2: Union[str, OperationMath2]) -> Image: ...
    def math2_const(self, math2: Union[str, OperationMath2], c: list[float]) -> Image: ...
    @staticmethod
    def matload(filename: str, memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def matrixinvert(self) -> Image: ...
    @staticmethod
    def matrixload(filename: str, memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def max(self, size: int = ..., x: bool = ..., y: bool = ..., out_array: bool = ..., x_array: bool = ..., y_array: bool = ...) -> Union[float, tuple[float, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def maxpair(self, right: Image) -> Image: ...
    def measure(self, h: int, v: int, left: int = ..., top: int = ..., width: int = ..., height: int = ...) -> Image: ...
    def merge(self, sec: Image, direction: Union[str, Direction], dx: int, dy: int, mblend: int = ...) -> Image: ...
    def min(self, size: int = ..., x: bool = ..., y: bool = ..., out_array: bool = ..., x_array: bool = ..., y_array: bool = ...) -> Union[float, tuple[float, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def minpair(self, right: Image) -> Image: ...
    def morph(self, mask: Image, morph: Union[str, OperationMorphology]) -> Image: ...
    def mosaic(self, sec: Image, direction: Union[str, Direction], xref: int, yref: int, xsec: int, ysec: int, hwindow: int = ..., harea: int = ..., mblend: int = ..., bandno: int = ..., dx0: bool = ..., dy0: bool = ..., scale1: bool = ..., angle1: bool = ..., dy1: bool = ..., dx1: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def mosaic1(self, sec: Image, direction: Union[str, Direction], xr1: int, yr1: int, xs1: int, ys1: int, xr2: int, yr2: int, xs2: int, ys2: int, hwindow: int = ..., harea: int = ..., search: bool = ..., interpolate: GObject = ..., mblend: int = ...) -> Image: ...
    def msb(self, band: int = ...) -> Image: ...
    def multiply(self, right: Image) -> Image: ...
    @staticmethod
    def openexrload(filename: str, memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def pdfload(filename: str, page: int = ..., n: int = ..., dpi: float = ..., scale: float = ..., background: list[float] = ..., password: str = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def pdfload_buffer(buffer: str, page: int = ..., n: int = ..., dpi: float = ..., scale: float = ..., background: list[float] = ..., password: str = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def percent(self, percent: float) -> int: ...
    @staticmethod
    def perlin(width: int, height: int, cell_size: int = ..., uchar: bool = ..., seed: int = ...) -> Image: ...
    def phasecor(self, in2: Image) -> Image: ...
    @staticmethod
    def pngload(filename: str, unlimited: bool = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def pngload_buffer(buffer: str, unlimited: bool = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def ppmload(filename: str, memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def premultiply(self, max_alpha: float = ...) -> Image: ...
    def prewitt(self) -> Image: ...
    def profile(self) -> tuple[Image, Image]: ...
    @staticmethod
    def profile_load(name: str) -> str: ...
    def project(self) -> tuple[Image, Image]: ...
    def quadratic(self, coeff: Image, interpolate: GObject = ...) -> Image: ...
    def rad2float(self) -> Image: ...
    @staticmethod
    def radload(filename: str, memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def radload_buffer(buffer: str, memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def rank(self, width: int, height: int, index: int) -> Image: ...
    @staticmethod
    def rawload(filename: str, width: int, height: int, bands: int, offset: int = ..., format: Union[str, BandFormat] = ..., interpretation: Union[str, Interpretation] = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def recomb(self, m: Image) -> Image: ...
    def reduce(self, hshrink: float, vshrink: float, kernel: Union[str, Kernel] = ..., gap: float = ...) -> Image: ...
    def reduceh(self, hshrink: float, kernel: Union[str, Kernel] = ..., gap: float = ...) -> Image: ...
    def reducev(self, vshrink: float, kernel: Union[str, Kernel] = ..., gap: float = ...) -> Image: ...
    def relational(self, right: Image, relational: Union[str, OperationRelational]) -> Image: ...
    def relational_const(self, relational: Union[str, OperationRelational], c: list[float]) -> Image: ...
    def remainder(self, right: Image) -> Image: ...
    def remainder_const(self, c: list[float]) -> Image: ...
    def replicate(self, across: int, down: int) -> Image: ...
    def resize(self, scale: float, kernel: Union[str, Kernel] = ..., gap: float = ..., vscale: float = ...) -> Image: ...
    def rot(self, angle: Union[str, Angle]) -> Image: ...
    def rot45(self, angle: Union[str, Angle45] = ...) -> Image: ...
    def rotate(self, angle: float, interpolate: GObject = ..., background: list[float] = ..., odx: float = ..., ody: float = ..., idx: float = ..., idy: float = ...) -> Image: ...
    def round(self, round: Union[str, OperationRound]) -> Image: ...
    def sRGB2HSV(self) -> Image: ...
    def sRGB2scRGB(self) -> Image: ...
    def scRGB2BW(self, depth: int = ...) -> Image: ...
    def scRGB2XYZ(self) -> Image: ...
    def scRGB2sRGB(self, depth: int = ...) -> Image: ...
    def scharr(self) -> Image: ...
    @staticmethod
    def sdf(width: int, height: int, shape: Union[str, SdfShape], r: float = ..., a: list[float] = ..., b: list[float] = ..., corners: list[float] = ...) -> Image: ...
    def sequential(self, tile_height: int = ...) -> Image: ...
    def sharpen(self, sigma: float = ..., x1: float = ..., y2: float = ..., y3: float = ..., m1: float = ..., m2: float = ...) -> Image: ...
    def shrink(self, hshrink: float, vshrink: float, ceil: bool = ...) -> Image: ...
    def shrinkh(self, hshrink: int, ceil: bool = ...) -> Image: ...
    def shrinkv(self, vshrink: int, ceil: bool = ...) -> Image: ...
    def sign(self) -> Image: ...
    def similarity(self, scale: float = ..., angle: float = ..., interpolate: GObject = ..., background: list[float] = ..., odx: float = ..., ody: float = ..., idx: float = ..., idy: float = ...) -> Image: ...
    @staticmethod
    def sines(width: int, height: int, uchar: bool = ..., hfreq: float = ..., vfreq: float = ...) -> Image: ...
    def smartcrop(self, width: int, height: int, interesting: Union[str, Interesting] = ..., premultiplied: bool = ..., attention_x: bool = ..., attention_y: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def sobel(self) -> Image: ...
    def spcor(self, ref: Image) -> Image: ...
    def spectrum(self) -> Image: ...
    def stats(self) -> Image: ...
    def stdif(self, width: int, height: int, s0: float = ..., b: float = ..., m0: float = ..., a: float = ...) -> Image: ...
    def subsample(self, xfac: int, yfac: int, point: bool = ...) -> Image: ...
    def subtract(self, right: Image) -> Image: ...
    @staticmethod
    def sum(in_: list[Image]) -> Image: ...
    @staticmethod
    def svgload(filename: str, dpi: float = ..., scale: float = ..., unlimited: bool = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def svgload_buffer(buffer: str, dpi: float = ..., scale: float = ..., unlimited: bool = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def switch(tests: list[Image]) -> Image: ...
    @staticmethod
    def text(text: str, font: str = ..., width: int = ..., height: int = ..., align: Union[str, Align] = ..., justify: bool = ..., dpi: int = ..., spacing: int = ..., fontfile: str = ..., rgba: bool = ..., wrap: Union[str, TextWrap] = ..., autofit_dpi: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def tiffload(filename: str, page: int = ..., subifd: int = ..., n: int = ..., autorotate: bool = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def tiffload_buffer(buffer: str, page: int = ..., subifd: int = ..., n: int = ..., autorotate: bool = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    def tilecache(self, tile_width: int = ..., tile_height: int = ..., max_tiles: int = ..., access: Union[str, Access] = ..., threaded: bool = ..., persistent: bool = ...) -> Image: ...
    @staticmethod
    def tonelut(in_max: int = ..., out_max: int = ..., Lb: float = ..., Lw: float = ..., Ps: float = ..., Pm: float = ..., Ph: float = ..., S: float = ..., M: float = ..., H: float = ...) -> Image: ...
    def transpose3d(self, page_height: int = ...) -> Image: ...
    def unpremultiply(self, max_alpha: float = ..., alpha_band: int = ...) -> Image: ...
    @staticmethod
    def vipsload(filename: str, memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def webpload(filename: str, page: int = ..., n: int = ..., scale: float = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def webpload_buffer(buffer: str, page: int = ..., n: int = ..., scale: float = ..., memory: bool = ..., access: Union[str, Access] = ..., fail_on: Union[str, FailOn] = ..., revalidate: bool = ..., flags: bool = ...) -> Union[Image, tuple[Image, Dict[str, Union[bool, int, float, str, Image, list[int], list[float], list[Image]]]]]: ...
    @staticmethod
    def worley(width: int, height: int, cell_size: int = ..., seed: int = ...) -> Image: ...
    def wrap(self, x: int = ..., y: int = ...) -> Image: ...
    @staticmethod
    def xyz(width: int, height: int, csize: int = ..., dsize: int = ..., esize: int = ...) -> Image: ...
    @staticmethod
    def zone(width: int, height: int, uchar: bool = ...) -> Image: ...
    def zoom(self, xfac: int, yfac: int) -> Image: ...

    # Operator overloads
    def __add__(self, other: Union[Image, float, int]) -> Image: ...
    def __radd__(self, other: Union[float, int]) -> Image: ...
    def __sub__(self, other: Union[Image, float, int]) -> Image: ...
    def __rsub__(self, other: Union[float, int]) -> Image: ...
    def __mul__(self, other: Union[Image, float, int]) -> Image: ...
    def __rmul__(self, other: Union[float, int]) -> Image: ...
    def __truediv__(self, other: Union[Image, float, int]) -> Image: ...
    def __rtruediv__(self, other: Union[float, int]) -> Image: ...
    def __floordiv__(self, other: Union[Image, float, int]) -> Image: ...
    def __rfloordiv__(self, other: Union[float, int]) -> Image: ...
    def __mod__(self, other: Union[Image, float, int]) -> Image: ...
    def __pow__(self, other: Union[Image, float, int]) -> Image: ...
    def __rpow__(self, other: Union[Image, float, int]) -> Image: ...
    def __abs__(self) -> Image: ...
    def __neg__(self) -> Image: ...
    def __pos__(self) -> Image: ...
    def __invert__(self) -> Image: ...
    def __lshift__(self, other: Union[Image, float, int]) -> Image: ...
    def __rshift__(self, other: Union[Image, float, int]) -> Image: ...
    def __and__(self, other: Union[Image, float, int]) -> Image: ...
    def __rand__(self, other: Union[Image, float, int]) -> Image: ...
    def __or__(self, other: Union[Image, float, int]) -> Image: ...
    def __ror__(self, other: Union[Image, float, int]) -> Image: ...
    def __xor__(self, other: Union[Image, float, int]) -> Image: ...
    def __rxor__(self, other: Union[Image, float, int]) -> Image: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: Union[Image, float, int]) -> Image: ...
    def __ge__(self, other: Union[Image, float, int]) -> Image: ...
    def __lt__(self, other: Union[Image, float, int]) -> Image: ...
    def __le__(self, other: Union[Image, float, int]) -> Image: ...

    def __getitem__(self, arg: Union[int, slice, List[int], List[bool]]) -> Image: ...
    def __call__(self, x: int, y: int) -> List[float]: ...
    def __repr__(self) -> str: ...


class Operation: ...
class Introspect: ...

# Global functions
def cache_set_max(mx: int) -> None: ...
def cache_set_max_mem(mx: int) -> None: ...
def cache_set_max_files(mx: int) -> None: ...
def cache_set_trace(trace: bool) -> None: ...
def cache_get_max() -> int: ...
def cache_get_size() -> int: ...
def cache_get_max_mem() -> int: ...
def cache_get_max_files() -> int: ...
def block_untrusted_set(state: bool) -> None: ...
def operation_block_set(name: str, state: bool) -> None: ...

# Module-level constants
API_mode: bool
